-- Add new columns and defaults to crew table
ALTER TABLE public."crew"
  ALTER COLUMN crew_id ADD GENERATED BY DEFAULT AS IDENTITY,
  ALTER COLUMN max_member SET DEFAULT 20,
  ADD COLUMN IF NOT EXISTS leader_user_id integer,
  ADD COLUMN IF NOT EXISTS introduction text,
  ADD COLUMN IF NOT EXISTS created_at timestamptz DEFAULT now();

-- Maintain area_id as primary area (optional)

-- Set max_member default to 20 for existing rows
UPDATE public."crew" SET max_member = 20 WHERE max_member IS NULL;

-- Create crew area mapping table
CREATE TABLE IF NOT EXISTS public.crew_area_map (
  crew_id integer NOT NULL REFERENCES public."crew"(crew_id) ON DELETE CASCADE,
  area_id integer NOT NULL REFERENCES public.area(area_id),
  PRIMARY KEY (crew_id, area_id)
);

ALTER TABLE public.crew_area_map OWNER TO postgres;

-- Enable row level security and policies for crew and mapping tables
ALTER TABLE public."crew" ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.crew_area_map ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS crew_select_all ON public."crew";
CREATE POLICY crew_select_all ON public."crew"
  FOR SELECT TO authenticated
  USING (true);

DROP POLICY IF EXISTS crew_area_map_select ON public.crew_area_map;
CREATE POLICY crew_area_map_select ON public.crew_area_map
  FOR SELECT TO authenticated
  USING (true);

-- Create storage bucket for crew logos if not exists
INSERT INTO storage.buckets (id, name, public)
VALUES ('crew-logos', 'crew-logos', true)
ON CONFLICT (id) DO NOTHING;

-- Function to get weekly crew rankings
CREATE OR REPLACE FUNCTION public.get_weekly_crew_rankings(
  target_week text DEFAULT NULL,
  fetch_limit int DEFAULT 100,
  fetch_offset int DEFAULT 0
) RETURNS TABLE (
  rank integer,
  crew_id integer,
  crew_name text,
  logo_url text,
  member_count integer,
  weekly_score numeric,
  total_score integer
) LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  week_id text;
BEGIN
  PERFORM set_config('search_path', 'public', true);
  week_id := COALESCE(target_week, to_char((now() AT TIME ZONE 'Asia/Seoul')::date, 'IYYY-IW'));
  RETURN QUERY
  WITH base AS (
    SELECT
      c.crew_id,
      c.crew_name,
      c.logo_url,
      COALESCE(c.max_member, 20) AS max_member,
      COALESCE(c.total_score, 0) AS total_score,
      COALESCE(cws.score, 0) AS weekly_score,
      (SELECT COUNT(*) FROM public."user" u WHERE u.crew_id = c.crew_id) AS member_count
    FROM public."crew" c
    LEFT JOIN public.crew_weekly_scores cws
      ON cws.crew_id = c.crew_id AND cws.week_id = week_id
  ), ranked AS (
    SELECT
      crew_id,
      crew_name,
      logo_url,
      member_count,
      weekly_score,
      total_score,
      ROW_NUMBER() OVER (ORDER BY weekly_score DESC, total_score DESC, crew_name) AS rnk
    FROM base
  )
  SELECT
    rnk, crew_id, crew_name, logo_url, member_count,
    weekly_score, total_score
  FROM ranked
  ORDER BY rnk
  LIMIT COALESCE(fetch_limit, 100)
  OFFSET COALESCE(fetch_offset, 0);
END;
$$;

-- Function to get total crew rankings
CREATE OR REPLACE FUNCTION public.get_total_crew_rankings(
  fetch_limit int DEFAULT 100,
  fetch_offset int DEFAULT 0
) RETURNS TABLE (
  rank integer,
  crew_id integer,
  crew_name text,
  logo_url text,
  member_count integer,
  total_score integer
) LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  PERFORM set_config('search_path', 'public', true);
  RETURN QUERY
  WITH base AS (
    SELECT
      c.crew_id,
      c.crew_name,
      c.logo_url,
      COALESCE(c.total_score, 0) AS total_score,
      (SELECT COUNT(*) FROM public."user" u WHERE u.crew_id = c.crew_id) AS member_count
    FROM public."crew" c
  ), ranked AS (
    SELECT
      crew_id,
      crew_name,
      logo_url,
      member_count,
      total_score,
      ROW_NUMBER() OVER (ORDER BY total_score DESC, crew_name) AS rnk
    FROM base
  )
  SELECT
    rnk, crew_id, crew_name, logo_url, member_count, total_score
  FROM ranked
  ORDER BY rnk
  LIMIT COALESCE(fetch_limit, 100)
  OFFSET COALESCE(fetch_offset, 0);
END;
$$;

-- Function to get my crew summary
CREATE OR REPLACE FUNCTION public.get_my_crew_summary(
  p_auth_user_id uuid,
  target_week text DEFAULT NULL
) RETURNS TABLE (
  crew_id integer,
  crew_name text,
  logo_url text,
  member_count integer,
  weekly_score numeric,
  weekly_rank integer,
  total_score integer,
  total_rank integer
) LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  week_id text;
  v_user_id integer;
BEGIN
  PERFORM set_config('search_path', 'public', true);
  SELECT user_id INTO v_user_id FROM public."user" WHERE auth_user_id = p_auth_user_id;
  IF v_user_id IS NULL THEN
    RETURN;
  END IF;
  week_id := COALESCE(target_week, to_char((now() AT TIME ZONE 'Asia/Seoul')::date, 'IYYY-IW'));

  RETURN QUERY
  WITH crew_base AS (
    SELECT
      c.crew_id,
      c.crew_name,
      c.logo_url,
      COALESCE(c.total_score, 0) AS total_score,
      COALESCE(cws.score, 0) AS weekly_score,
      (SELECT COUNT(*) FROM public."user" u WHERE u.crew_id = c.crew_id) AS member_count
    FROM public."crew" c
    LEFT JOIN public.crew_weekly_scores cws
      ON cws.crew_id = c.crew_id AND cws.week_id = week_id
  ), weekly_ranked AS (
    SELECT
      cb.*, ROW_NUMBER() OVER (ORDER BY cb.weekly_score DESC, cb.total_score DESC, cb.crew_name) AS weekly_rank
    FROM crew_base cb
  ), total_ranked AS (
    SELECT
      cb.*, ROW_NUMBER() OVER (ORDER BY cb.total_score DESC, cb.crew_name) AS total_rank
    FROM crew_base cb
  )
  SELECT
    wr.crew_id,
    wr.crew_name,
    wr.logo_url,
    wr.member_count,
    wr.weekly_score,
    wr.weekly_rank,
    tr.total_score,
    tr.total_rank
  FROM weekly_ranked wr
  JOIN total_ranked tr USING (crew_id, crew_name, logo_url, member_count, weekly_score, total_score)
  WHERE wr.crew_id = (SELECT crew_id FROM public."user" WHERE user_id = v_user_id);
END;
$$;

-- Function to retrieve crew detail overview
CREATE OR REPLACE FUNCTION public.get_crew_overview(
  p_crew_id integer,
  target_week text DEFAULT NULL
) RETURNS TABLE (
  crew_id integer,
  crew_name text,
  logo_url text,
  member_count integer,
  max_member integer,
  weekly_score numeric,
  weekly_rank integer,
  total_score integer,
  total_rank integer,
  introduction text
) LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  week_id text;
BEGIN
  PERFORM set_config('search_path', 'public', true);
  week_id := COALESCE(target_week, to_char((now() AT TIME ZONE 'Asia/Seoul')::date, 'IYYY-IW'));
  RETURN QUERY
  WITH crew_base AS (
    SELECT
      c.crew_id,
      c.crew_name,
      c.logo_url,
      COALESCE(c.total_score, 0) AS total_score,
      COALESCE(cws.score, 0) AS weekly_score,
      COALESCE(c.max_member, 20) AS max_member,
      COALESCE(c.introduction, '') AS introduction,
      (SELECT COUNT(*) FROM public."user" u WHERE u.crew_id = c.crew_id) AS member_count
    FROM public."crew" c
    LEFT JOIN public.crew_weekly_scores cws
      ON cws.crew_id = c.crew_id AND cws.week_id = week_id
  ), weekly_ranked AS (
    SELECT cb.*, ROW_NUMBER() OVER (ORDER BY cb.weekly_score DESC, cb.total_score DESC, cb.crew_name) AS weekly_rank
    FROM crew_base cb
  ), total_ranked AS (
    SELECT cb.*, ROW_NUMBER() OVER (ORDER BY cb.total_score DESC, cb.crew_name) AS total_rank
    FROM crew_base cb
  )
  SELECT
    wr.crew_id,
    wr.crew_name,
    wr.logo_url,
    wr.member_count,
    wr.max_member,
    wr.weekly_score,
    wr.weekly_rank,
    tr.total_score,
    tr.total_rank,
    wr.introduction
  FROM weekly_ranked wr
  JOIN total_ranked tr USING (crew_id, crew_name, logo_url, member_count, weekly_score, total_score, max_member, introduction)
  WHERE wr.crew_id = p_crew_id;
END;
$$;

-- Function to fetch crew members ordered by leader then total score
CREATE OR REPLACE FUNCTION public.get_crew_members(
  p_crew_id integer
) RETURNS TABLE (
  rank integer,
  user_id integer,
  user_name text,
  is_leader boolean,
  weekly_score integer,
  total_score integer
) LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  PERFORM set_config('search_path', 'public', true);
  RETURN QUERY
  WITH members AS (
    SELECT
      u.user_id,
      u.name,
      u.weekly_score,
      u.total_score,
      (u.user_id = c.leader_user_id) AS is_leader
    FROM public."user" u
    JOIN public."crew" c ON c.crew_id = p_crew_id
    WHERE u.crew_id = p_crew_id
  ), ranked AS (
    SELECT
      user_id,
      name,
      weekly_score,
      total_score,
      is_leader,
      ROW_NUMBER() OVER (PARTITION BY NOT is_leader ORDER BY total_score DESC, name) AS pos
    FROM members
  )
  SELECT
    CASE WHEN is_leader THEN 1 ELSE pos + 1 END AS rank,
    user_id,
    name,
    is_leader,
    weekly_score,
    total_score
  FROM ranked
  ORDER BY CASE WHEN is_leader THEN 0 ELSE 1 END, rank;
END;
$$;

-- Function to create a new crew
CREATE OR REPLACE FUNCTION public.create_crew(
  p_auth_user_id uuid,
  p_crew_name text,
  p_logo_url text,
  p_area_ids integer[],
  p_introduction text DEFAULT NULL
) RETURNS TABLE (
  crew_id integer,
  crew_name text,
  logo_url text,
  member_count integer,
  max_member integer
) LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  v_user RECORD;
  v_crew_id integer;
  v_area_id integer;
  v_limit integer;
  i integer;
BEGIN
  PERFORM set_config('search_path', 'public', true);
  SELECT user_id, name, crew_id INTO v_user FROM public."user" WHERE auth_user_id = p_auth_user_id;
  IF v_user.user_id IS NULL THEN
    RAISE EXCEPTION 'User not found';
  END IF;
  IF v_user.crew_id IS NOT NULL THEN
    RAISE EXCEPTION '이미 크루에 소속되어 있습니다.';
  END IF;

  INSERT INTO public."crew" (crew_name, leader_name, leader_user_id, max_member, logo_url, introduction)
  VALUES (p_crew_name, v_user.name, v_user.user_id, 20, p_logo_url, p_introduction)
  RETURNING crew_id INTO v_crew_id;

  -- Update optional primary area using first selected area
  IF p_area_ids IS NOT NULL AND array_length(p_area_ids, 1) >= 1 THEN
    UPDATE public."crew" SET area_id = p_area_ids[1] WHERE crew_id = v_crew_id;
  END IF;

  -- Map areas (limit to first 3 entries)
  IF p_area_ids IS NOT NULL THEN
    v_limit := LEAST(array_length(p_area_ids, 1), 3);
    IF v_limit IS NOT NULL THEN
      FOR i IN 1..v_limit LOOP
        v_area_id := p_area_ids[i];
        IF v_area_id IS NOT NULL THEN
          INSERT INTO public.crew_area_map (crew_id, area_id)
          VALUES (v_crew_id, v_area_id)
          ON CONFLICT DO NOTHING;
        END IF;
      END LOOP;
    END IF;
  END IF;

  -- Attach creator to crew
  UPDATE public."user" SET crew_id = v_crew_id WHERE user_id = v_user.user_id;

  RETURN QUERY
  SELECT
    c.crew_id,
    c.crew_name,
    c.logo_url,
    (SELECT COUNT(*) FROM public."user" u WHERE u.crew_id = c.crew_id) AS member_count,
    COALESCE(c.max_member, 20)
  FROM public."crew" c
  WHERE c.crew_id = v_crew_id;
END;
$$;
